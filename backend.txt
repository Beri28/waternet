// --- Project Structure (Conceptual) ---
// This code is presented as a single runnable block. In a real project,
// it would be organized into directories like:
//
// ├── node_modules/
// ├── prisma/
// │   └── schema.prisma
// ├── controllers/
// │   ├── authController.js
// │   ├── userController.js
// │   ├── organizationController.js
// │   ├── regionController.js
// │   ├── districtController.js
// │   ├── villageController.js
// │   ├── waterSourceTypeController.js
// │   ├── waterSourceController.js
// │   ├── infraAssetTypeController.js
// │   ├── infraAssetController.js
// │   ├── meterReadingController.js
// │   ├── leakReportController.js
// │   ├── waterQualityTestController.js
// │   ├── citizenAccountController.js
// │   ├── propertyController.js
// │   ├── billController.js
// │   └── announcementController.js
// ├── routes/
// │   ├── authRoutes.js
// │   ├── userRoutes.js
// │   ├── organizationRoutes.js
// │   ├── regionRoutes.js
// │   ├── districtRoutes.js
// │   ├── villageRoutes.js
// │   ├── waterSourceTypeRoutes.js
// │   ├── waterSourceRoutes.js
// │   ├── infraAssetTypeRoutes.js
// │   ├── infraAssetRoutes.js
// │   ├── meterReadingRoutes.js
// │   ├── leakReportRoutes.js
// │   ├── waterQualityTestRoutes.js
// │   ├── citizenAccountRoutes.js
// │   ├── propertyRoutes.js
// │   ├── billRoutes.js
// │   └── announcementRoutes.js
// ├── config/
// │   └── swaggerConfig.js
// ├── utils/
// │   └── prisma.js
// └── server.js
//
// To run this code:
// 1. Install Node.js
// 2. Create a new directory for your project.
// 3. Create a 'package.json' file with the following dependencies:
//    {
//      "name": "waternet-api",
//      "version": "1.0.0",
//      "description": "WaterNet Management API",
//      "main": "server.js",
//      "scripts": {
//        "start": "node server.js",
//        "dev": "nodemon server.js",
//        "prisma:migrate": "npx prisma migrate dev --name init --preview-feature",
//        "prisma:generate": "npx prisma generate",
//        "prisma:seed": "node prisma/seed.js"
//      },
//      "dependencies": {
//        "@prisma/client": "^5.x.x", // Use the latest stable version
//        "express": "^4.18.2",
//        "body-parser": "^1.20.2",
//        "cors": "^2.8.5",
//        "swagger-jsdoc": "^6.2.8",
//        "swagger-ui-express": "^5.0.0"
//      },
//      "devDependencies": {
//        "prisma": "^5.x.x", // Use the latest stable version
//        "nodemon": "^3.0.1"
//      }
//    }
// 4. Run `npm install`
// 5. Create the 'prisma' directory and 'schema.prisma' file inside it.
// 6. Create the 'utils' directory and 'prisma.js' inside it.
// 7. Create the 'config' directory and 'swaggerConfig.js' inside it.
// 8. Create 'controllers' and 'routes' directories.
// 9. Copy the respective code blocks into their files.
// 10. Run `npx prisma migrate dev --name init --preview-feature` to apply schema to PostgreSQL.
//     Make sure your PostgreSQL database is running and DATABASE_URL is set in .env or hardcoded below.
// 11. Run `npm start` or `npm run dev` (if nodemon is installed).
// 12. Access Swagger UI at `http://localhost:3000/api-docs`.

// --- 1. prisma/schema.prisma ---
// This file defines your database schema.
// You need to configure your database connection string in a .env file or directly here.
/*
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // Example: "postgresql://user:password@localhost:5432/waternet_db"
}

generator client {
  provider = "prisma-client-js"
}

// User types for Main App, Citizen App, Field Officer App
enum UserRole {
  Administrator
  Planner
  FieldOfficer
  NGOUser
  Citizen
}

enum AssetCondition {
  Good
  Fair
  Poor
  Critical
  Decommissioned
}

enum LeakSeverity {
  Minor
  Moderate
  Major
  Critical
}

enum ReportStatus {
  Reported
  UnderInvestigation
  Resolved
  Closed
  FalseReport
  Mitigated
}

enum OrgType {
  Government
  NGO
  Private
}

enum BillStatus {
  Paid
  Pending
  Overdue
}

enum BillType {
  WaterConsumption
  MaintenanceFee
}

model User {
  id                String       @id @default(uuid()) @map("user_id")
  username          String       @unique
  email             String?      @unique
  fullName          String       @map("full_name")
  password          String       // In a real app, hash this!
  role              UserRole
  organizationId    String       @map("org_id")
  isActive          Boolean      @default(true) @map("is_active")
  lastLogin         DateTime?    @map("last_login")
  createdAt         DateTime     @default(now()) @map("created_at")
  updatedAt         DateTime     @updatedAt @map("updated_at")

  organization      Organization @relation(fields: [organizationId], references: [id])
  meterReadings     MeterReading[]
  leakReportsAssigned LeakReport[] @relation("AssignedLeakReports")
  waterQualityTests WaterQualityTest[]

  @@map("users")
}

model Organization {
  id             String     @id @default(uuid()) @map("org_id")
  name           String     @unique @map("org_name")
  type           OrgType    @map("org_type")
  contactEmail   String?    @map("contact_email")
  phoneNumber    String?    @map("phone_number")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  users          User[]

  @@map("organizations")
}

model Region {
  id             String     @id @default(uuid()) @map("region_id")
  name           String     @unique @map("region_name")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  districts      District[]

  @@map("regions")
}

model District {
  id             String     @id @default(uuid()) @map("district_id")
  name           String     @unique @map("district_name")
  regionId       String     @map("region_id")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  region         Region     @relation(fields: [regionId], references: [id])
  villages       Village[]
  infrastructureAssets InfrastructureAsset[]

  @@map("districts")
}

model Village {
  id             String     @id @default(uuid()) @map("village_id")
  name           String     @map("village_name")
  districtId     String     @map("district_id")
  populationCount Int?       @map("population_count")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  district       District   @relation(fields: [districtId], references: [id])
  waterSources   WaterSource[]
  properties     Property[]
  leakReportsReported LeakReport[] @relation("ReportedLeakReports")

  @@unique([name, districtId]) // Village name unique within a district
  @@map("villages")
}

model WaterSourceType {
  id             Int        @id @default(autoincrement()) @map("source_type_id")
  name           String     @unique @map("type_name")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  waterSources   WaterSource[]

  @@map("water_source_types")
}

model WaterSource {
  id             String     @id @default(uuid()) @map("source_id")
  name           String     @unique @map("source_name")
  sourceTypeId   Int        @map("source_type_id")
  locationGeom   String     @map("location_geom") // Stores PostGIS geometry as EWKT string for simplicity
  villageId      String?    @map("village_id")
  status         String?
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  sourceType     WaterSourceType @relation(fields: [sourceTypeId], references: [id])
  village        Village?   @relation(fields: [villageId], references: [id])
  waterQualityTests WaterQualityTest[]

  @@map("water_sources")
}

model InfrastructureAssetType {
  id             Int        @id @default(autoincrement()) @map("asset_type_id")
  name           String     @unique @map("type_name")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  infrastructureAssets InfrastructureAsset[]

  @@map("infrastructure_asset_types")
}

model InfrastructureAsset {
  id                   String           @id @default(uuid()) @map("asset_id")
  name                 String           @unique @map("asset_name")
  assetTypeId          Int              @map("asset_type_id")
  installationDate     DateTime?        @map("installation_date") @db.Date
  lastMaintenanceDate  DateTime?        @map("last_maintenance_date") @db.Date
  conditionStatus      AssetCondition?  @map("condition_status")
  locationGeom         String           @map("location_geom") // Stores PostGIS geometry as EWKT string for simplicity
  districtId           String           @map("district_id")
  capacityM3PerDay     Float?           @map("capacity_m3_per_day")
  createdAt            DateTime         @default(now()) @map("created_at")
  updatedAt            DateTime         @updatedAt @map("updated_at")

  assetType            InfrastructureAssetType @relation(fields: [assetTypeId], references: [id])
  district             District         @relation(fields: [districtId], references: [id])
  meterReadings        MeterReading[]
  leakReports          LeakReport[]
  waterQualityTests    WaterQualityTest[]
  properties           Property[]

  @@map("infrastructure_assets")
}

model MeterReading {
  id                   String        @id @default(uuid()) @map("reading_id")
  meterAssetId         String        @map("meter_asset_id")
  readingDate          DateTime      @map("reading_date") @db.Date
  volumeConsumedLiters Float         @map("volume_consumed_liters")
  reportedByUserId     String        @map("reported_by_user_id") // Could be Field Officer or Citizen
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")

  meterAsset           InfrastructureAsset @relation(fields: [meterAssetId], references: [id])
  reportedByUser       User          @relation(fields: [reportedByUserId], references: [id])

  @@map("meter_readings")
}

model LeakReport {
  id                         String        @id @default(uuid()) @map("leak_id")
  reportDate                 DateTime      @map("report_date") @db.Date
  locationDescription        String?       @map("location_description")
  severity                   LeakSeverity
  status                     ReportStatus
  resolutionDate             DateTime?     @map("resolution_date") @db.Date
  estimatedWaterLossLitersPerDay Float?    @map("estimated_water_loss_liters_per_day")
  reportedByVillageId        String?       @map("reported_by_village_id")
  assignedToUserId           String?       @map("assigned_to_user_id")
  infrastructureAssetId      String?       @map("infrastructure_asset_id")
  createdAt                  DateTime      @default(now()) @map("created_at")
  updatedAt                  DateTime      @updatedAt @map("updated_at")

  reportedByVillage          Village?      @relation("ReportedLeakReports", fields: [reportedByVillageId], references: [id])
  assignedToUser             User?         @relation("AssignedLeakReports", fields: [assignedToUserId], references: [id])
  infrastructureAsset        InfrastructureAsset? @relation(fields: [infrastructureAssetId], references: [id])

  @@map("leak_reports")
}

model WaterQualityTest {
  id                           String       @id @default(uuid()) @map("test_id")
  testDate                     DateTime     @map("test_date") @db.Date
  waterSourceId                String?      @map("water_source_id")
  infrastructureAssetId        String?      @map("infrastructure_asset_id")
  testingLab                   String?      @map("testing_lab")
  phLevel                      Float?       @map("ph_level")
  chlorineLevelMgPerL          Float?       @map("chlorine_level_mg_per_l")
  coliformCountCfuPer100ml     Int?         @map("coliform_count_cfu_per_100ml")
  otherParameters              Json?        @map("other_parameters") // JSONB type for flexible parameters
  testedByUserId               String?      @map("tested_by_user_id")
  createdAt                    DateTime     @default(now()) @map("created_at")
  updatedAt                    DateTime     @updatedAt @map("updated_at")

  waterSource                  WaterSource?         @relation(fields: [waterSourceId], references: [id])
  infrastructureAsset          InfrastructureAsset? @relation(fields: [infrastructureAssetId], references: [id])
  testedByUser                 User?                @relation(fields: [testedByUserId], references: [id])

  @@map("water_quality_tests")
}

// Citizen App specific models
model CitizenAccount {
  id             String     @id @default(uuid()) @map("citizen_id")
  fullName       String     @map("full_name")
  email          String?    @unique
  phoneNumber    String     @unique @map("phone_number")
  password       String     // In a real app, hash this!
  propertyId     String     @map("property_id")
  accountStatus  String     @map("account_status") // e.g., 'Active', 'Suspended'
  registeredAt   DateTime   @default(now()) @map("registered_at")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  property       Property   @relation(fields: [propertyId], references: [id])
  bills          Bill[]

  @@map("citizen_accounts")
}

model Property {
  id             String     @id @default(uuid()) @map("property_id")
  address        String
  villageId      String     @map("village_id")
  meterAssetId   String?    @map("meter_asset_id") // Link to an infrastructure asset that is a meter
  ownerCitizenId String?    @map("owner_citizen_id")
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  village        Village    @relation(fields: [villageId], references: [id])
  meterAsset     InfrastructureAsset? @relation(fields: [meterAssetId], references: [id])
  ownerCitizen   CitizenAccount? @relation(fields: [ownerCitizenId], references: [id])

  @@map("properties")
}

model Bill {
  id             String     @id @default(uuid()) @map("bill_id")
  citizenId      String     @map("citizen_id")
  propertyId     String     @map("property_id")
  issueDate      DateTime   @map("issue_date") @db.Date
  dueDate        DateTime   @map("due_date") @db.Date
  amountXaf      Float      @map("amount_xaf")
  status         BillStatus
  billType       BillType   @map("bill_type")
  periodStartDate DateTime? @map("period_start_date") @db.Date
  periodEndDate   DateTime? @map("period_end_date") @db.Date
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  citizen        CitizenAccount @relation(fields: [citizenId], references: [id])
  property       Property   @relation(fields: [propertyId], references: [id])

  @@map("bills")
}

model Announcement {
  id             String     @id @default(uuid()) @map("announcement_id")
  title          String
  content        String
  publishedAt    DateTime   @map("published_at") @db.Date
  author         String?
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  @@map("announcements")
}
*/

// --- 2. utils/prisma.js ---
// This file exports a singleton Prisma Client instance.
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();
module.exports = prisma;


// --- 3. config/swaggerConfig.js ---
// This file configures Swagger documentation.
const swaggerJsdoc = require('swagger-jsdoc');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'WaterNet API',
      version: '1.0.0',
      description: 'API documentation for the WaterNet Water Resource Management and Distribution System in Cameroon.',
      contact: {
        name: 'WaterNet Team',
        email: 'support@waternet.com',
      },
    },
    servers: [
      {
        url: 'http://localhost:3000/api/v1',
        description: 'Development Server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            id: { type: 'string', format: 'uuid' },
            username: { type: 'string' },
            email: { type: 'string', format: 'email', nullable: true },
            fullName: { type: 'string' },
            role: { type: 'string', enum: ['Administrator', 'Planner', 'FieldOfficer', 'NGOUser', 'Citizen'] },
            organizationId: { type: 'string', format: 'uuid' },
            isActive: { type: 'boolean' },
            createdAt: { type: 'string', format: 'date-time' },
            updatedAt: { type: 'string', format: 'date-time' },
          },
          required: ['username', 'fullName', 'role', 'organizationId'],
        },
        LoginRequest: {
          type: 'object',
          properties: {
            identifier: { type: 'string', description: 'Username, email, or phone number' },
            password: { type: 'string' },
            role: { type: 'string', enum: ['Administrator', 'Planner', 'FieldOfficer', 'NGOUser', 'Citizen'] },
          },
          required: ['identifier', 'password', 'role'],
        },
        AuthResponse: {
          type: 'object',
          properties: {
            token: { type: 'string', description: 'JWT Token' },
            user: { $ref: '#/components/schemas/User' },
          },
        },
        MeterReading: {
          type: 'object',
          properties: {
            id: { type: 'string', format: 'uuid' },
            meterAssetId: { type: 'string', format: 'uuid' },
            readingDate: { type: 'string', format: 'date' },
            volumeConsumedLiters: { type: 'number', format: 'float' },
            reportedByUserId: { type: 'string', format: 'uuid' },
            createdAt: { type: 'string', format: 'date-time' },
            updatedAt: { type: 'string', format: 'date-time' },
          },
          required: ['meterAssetId', 'readingDate', 'volumeConsumedLiters', 'reportedByUserId'],
        },
        LeakReport: {
          type: 'object',
          properties: {
            id: { type: 'string', format: 'uuid' },
            reportDate: { type: 'string', format: 'date' },
            locationDescription: { type: 'string', nullable: true },
            severity: { type: 'string', enum: ['Minor', 'Moderate', 'Major', 'Critical'] },
            status: { type: 'string', enum: ['Reported', 'UnderInvestigation', 'Resolved', 'Closed', 'FalseReport', 'Mitigated'] },
            resolutionDate: { type: 'string', format: 'date', nullable: true },
            estimatedWaterLossLitersPerDay: { type: 'number', format: 'float', nullable: true },
            reportedByVillageId: { type: 'string', format: 'uuid', nullable: true },
            assignedToUserId: { type: 'string', format: 'uuid', nullable: true },
            infrastructureAssetId: { type: 'string', format: 'uuid', nullable: true },
            createdAt: { type: 'string', format: 'date-time' },
            updatedAt: { type: 'string', format: 'date-time' },
          },
          required: ['reportDate', 'severity', 'status'],
        },
        // ... Add schemas for all other models (Organization, Region, District, Village,
        // WaterSourceType, WaterSource, InfrastructureAssetType, InfrastructureAsset,
        // WaterQualityTest, CitizenAccount, Property, Bill, Announcement)
        // For brevity, only a few are shown.
      },
    },
  },
  apis: [
    './routes/*.js', // Path to your route files
    './controllers/*.js' // Path to your controller files (if JSDoc is there)
  ],
};

const swaggerSpec = swaggerJsdoc(options);

module.exports = swaggerSpec;


// --- 4. controllers/authController.js ---
const prisma = require('../utils/prisma');

// Mock user/citizen passwords for demonstration.
// In a real app, passwords should be securely hashed (e.g., with bcrypt).
const MOCK_PASSWORDS = {
    'admin_user': 'admin',
    'planner_user': 'planner',
    'field_officer_douala': 'field',
    'field_officer_yaounde': 'field',
    'ngo_user': 'ngo',
    'sarah.mbonjo@example.com': 'citizen', // Citizen uses email/phone as identifier
    '+237677123456': 'citizen',
    'david.nkeng@example.com': 'citizen',
    '+237699765432': 'citizen',
};

/**
 * @swagger
 * /auth/login:
 * post:
 * summary: Authenticate a user (Admin/Planner/Field Officer) or Citizen
 * tags: [Authentication]
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/LoginRequest'
 * responses:
 * 200:
 * description: Authentication successful
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/AuthResponse'
 * 401:
 * description: Invalid credentials or unauthorized role
 * 500:
 * description: Server error
 */
exports.login = async (req, res) => {
    const { identifier, password, role } = req.body;

    try {
        let user;
        if (role === 'Citizen') {
            user = await prisma.citizenAccount.findFirst({
                where: {
                    OR: [{ email: identifier }, { phoneNumber: identifier }],
                },
            });
            if (!user) {
                return res.status(401).json({ message: 'Invalid citizen credentials' });
            }
        } else {
            user = await prisma.user.findFirst({
                where: {
                    OR: [{ username: identifier }, { email: identifier }],
                    role: role,
                },
            });
            if (!user) {
                return res.status(401).json({ message: `Invalid ${role} credentials` });
            }
        }

        // Mock password check
        const expectedPassword = MOCK_PASSWORDS[identifier] || null;
        if (!expectedPassword || password !== expectedPassword) {
            return res.status(401).json({ message: 'Invalid password' });
        }

        // In a real application, you would generate a JWT here
        const token = `mock-jwt-token-for-${user.username || user.fullName}`;

        // Return user data (excluding sensitive info like password)
        const userData = role === 'Citizen' ?
            { citizenId: user.id, fullName: user.fullName, email: user.email, phoneNumber: user.phoneNumber, propertyId: user.propertyId, role: 'Citizen' } :
            { id: user.id, username: user.username, fullName: user.fullName, role: user.role, organizationId: user.organizationId };

        res.status(200).json({ token, user: userData });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ message: 'Server error during login', error: error.message });
    }
};


// --- 5. controllers/userController.js ---
const prisma = require('../utils/prisma');

/**
 * @swagger
 * tags:
 * name: Users
 * description: User management for Admin/Planner roles
 */

/**
 * @swagger
 * /users:
 * get:
 * summary: Retrieve a list of all users
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: query
 * name: role
 * schema:
 * type: string
 * enum: [Administrator, Planner, FieldOfficer, NGOUser]
 * description: Filter users by role
 * responses:
 * 200:
 * description: A list of users.
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * $ref: '#/components/schemas/User'
 * 500:
 * description: Server error
 */
exports.getAllUsers = async (req, res) => {
  const { role } = req.query;
  try {
    const users = await prisma.user.findMany({
      where: role ? { role: role } : {},
      select: { id: true, username: true, email: true, fullName: true, role: true, organizationId: true, isActive: true, createdAt: true }
    });
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /users/{id}:
 * get:
 * summary: Get a user by ID
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: path
 * name: id
 * schema:
 * type: string
 * format: uuid
 * required: true
 * description: User ID
 * responses:
 * 200:
 * description: User data
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/User'
 * 404:
 * description: User not found
 * 500:
 * description: Server error
 */
exports.getUserById = async (req, res) => {
  const { id } = req.params;
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      select: { id: true, username: true, email: true, fullName: true, role: true, organizationId: true, isActive: true, createdAt: true }
    });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /users:
 * post:
 * summary: Create a new user
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * required:
 * - username
 * - password
 * - fullName
 * - role
 * - organizationId
 * properties:
 * username: { type: string }
 * password: { type: string }
 * fullName: { type: string }
 * email: { type: string, format: email, nullable: true }
 * role: { type: string, enum: [Administrator, Planner, FieldOfficer, NGOUser] }
 * organizationId: { type: string, format: uuid }
 * isActive: { type: boolean, default: true }
 * responses:
 * 201:
 * description: User created successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/User'
 * 400:
 * description: Invalid input
 * 500:
 * description: Server error
 */
exports.createUser = async (req, res) => {
  const { username, password, fullName, email, role, organizationId, isActive } = req.body;
  try {
    // In a real app, hash the password before saving
    const newUser = await prisma.user.create({
      data: { username, password, fullName, email, role, organizationId, isActive },
      select: { id: true, username: true, email: true, fullName: true, role: true, organizationId: true, isActive: true, createdAt: true }
    });
    res.status(201).json(newUser);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /users/{id}:
 * put:
 * summary: Update an existing user
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: path
 * name: id
 * schema:
 * type: string
 * format: uuid
 * required: true
 * description: User ID
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * properties:
 * username: { type: string }
 * fullName: { type: string }
 * email: { type: string, format: email, nullable: true }
 * role: { type: string, enum: [Administrator, Planner, FieldOfficer, NGOUser] }
 * organizationId: { type: string, format: uuid }
 * isActive: { type: boolean }
 * responses:
 * 200:
 * description: User updated successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/User'
 * 404:
 * description: User not found
 * 500:
 * description: Server error
 */
exports.updateUser = async (req, res) => {
  const { id } = req.params;
  const { username, fullName, email, role, organizationId, isActive } = req.body;
  try {
    const updatedUser = await prisma.user.update({
      where: { id },
      data: { username, fullName, email, role, organizationId, isActive },
      select: { id: true, username: true, email: true, fullName: true, role: true, organizationId: true, isActive: true, createdAt: true }
    });
    res.json(updatedUser);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /users/{id}:
 * delete:
 * summary: Delete a user
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: path
 * name: id
 * schema:
 * type: string
 * format: uuid
 * required: true
 * description: User ID
 * responses:
 * 204:
 * description: User deleted successfully
 * 404:
 * description: User not found
 * 500:
 * description: Server error
 */
exports.deleteUser = async (req, res) => {
  const { id } = req.params;
  try {
    await prisma.user.delete({ where: { id } });
    res.status(204).send(); // No Content
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// --- Add similar CRUD controllers for all other models ---
// e.g., organizationController.js, regionController.js, districtController.js, etc.
// For brevity, only a few essential ones will be shown here as full implementations.

// --- 6. controllers/meterReadingController.js ---
const prisma = require('../utils/prisma');

/**
 * @swagger
 * tags:
 * name: MeterReadings
 * description: Management of meter readings
 */

/**
 * @swagger
 * /meter-readings:
 * get:
 * summary: Retrieve a list of all meter readings
 * tags: [MeterReadings]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: query
 * name: reportedByUserId
 * schema:
 * type: string
 * format: uuid
 * description: Filter readings by the ID of the reporting user (Field Officer or Citizen)
 * - in: query
 * name: meterAssetId
 * schema:
 * type: string
 * format: uuid
 * description: Filter readings by the ID of the meter asset
 * responses:
 * 200:
 * description: A list of meter readings.
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * $ref: '#/components/schemas/MeterReading'
 * 500:
 * description: Server error
 */
exports.getAllMeterReadings = async (req, res) => {
  const { reportedByUserId, meterAssetId } = req.query;
  const where = {};
  if (reportedByUserId) where.reportedByUserId = reportedByUserId;
  if (meterAssetId) where.meterAssetId = meterAssetId;

  try {
    const readings = await prisma.meterReading.findMany({
      where,
      orderBy: { readingDate: 'desc' },
      include: { meterAsset: { select: { name: true } }, reportedByUser: { select: { fullName: true, role: true } } },
    });
    res.json(readings);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /meter-readings:
 * post:
 * summary: Create a new meter reading
 * tags: [MeterReadings]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * required:
 * - meterAssetId
 * - readingDate
 * - volumeConsumedLiters
 * - reportedByUserId
 * properties:
 * meterAssetId: { type: string, format: uuid }
 * readingDate: { type: string, format: date, description: "YYYY-MM-DD" }
 * volumeConsumedLiters: { type: number, format: float }
 * reportedByUserId: { type: string, format: uuid }
 * responses:
 * 201:
 * description: Meter reading created successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/MeterReading'
 * 400:
 * description: Invalid input
 * 500:
 * description: Server error
 */
exports.createMeterReading = async (req, res) => {
  const { meterAssetId, readingDate, volumeConsumedLiters, reportedByUserId } = req.body;
  try {
    const newReading = await prisma.meterReading.create({
      data: { meterAssetId, readingDate: new Date(readingDate), volumeConsumedLiters, reportedByUserId },
    });
    res.status(201).json(newReading);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /meter-readings/bulk:
 * post:
 * summary: Bulk create new meter readings
 * tags: [MeterReadings]
 * description: Accepts an array of meter reading objects for bulk insertion.
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * type: object
 * required:
 * - meterAssetId
 * - readingDate
 * - volumeConsumedLiters
 * - reportedByUserId
 * properties:
 * meterAssetId: { type: string, format: uuid }
 * readingDate: { type: string, format: date, description: "YYYY-MM-DD" }
 * volumeConsumedLiters: { type: number, format: float }
 * reportedByUserId: { type: string, format: uuid }
 * responses:
 * 201:
 * description: Meter readings created successfully
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * $ref: '#/components/schemas/MeterReading'
 * 400:
 * description: Invalid input or data format
 * 500:
 * description: Server error
 */
exports.bulkCreateMeterReadings = async (req, res) => {
  const readings = req.body; // Expecting an array of reading objects
  if (!Array.isArray(readings) || readings.length === 0) {
    return res.status(400).json({ message: 'Request body must be a non-empty array of meter readings.' });
  }

  try {
    const dataToCreate = readings.map(r => ({
      ...r,
      readingDate: new Date(r.readingDate) // Convert date string to Date object
    }));
    const result = await prisma.meterReading.createMany({
      data: dataToCreate,
      skipDuplicates: true, // Optional: skip if a unique constraint exists
    });
    res.status(201).json({ count: result.count, message: `${result.count} readings created successfully.` });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// --- 7. controllers/leakReportController.js ---
const prisma = require('../utils/prisma');

/**
 * @swagger
 * tags:
 * name: LeakReports
 * description: Management of water leak reports
 */

/**
 * @swagger
 * /leak-reports:
 * get:
 * summary: Retrieve a list of all leak reports
 * tags: [LeakReports]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: query
 * name: status
 * schema:
 * type: string
 * enum: [Reported, UnderInvestigation, Resolved, Closed, FalseReport, Mitigated]
 * description: Filter reports by status
 * - in: query
 * name: assignedToUserId
 * schema:
 * type: string
 * format: uuid
 * description: Filter reports by assigned user ID (for Field Officers)
 * responses:
 * 200:
 * description: A list of leak reports.
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * $ref: '#/components/schemas/LeakReport'
 * 500:
 * description: Server error
 */
exports.getAllLeakReports = async (req, res) => {
  const { status, assignedToUserId } = req.query;
  const where = {};
  if (status) where.status = status;
  if (assignedToUserId) where.assignedToUserId = assignedToUserId;

  try {
    const reports = await prisma.leakReport.findMany({
      where,
      orderBy: { reportDate: 'desc' },
      include: {
        reportedByVillage: { select: { name: true } },
        assignedToUser: { select: { fullName: true } },
        infrastructureAsset: { select: { name: true } }
      }
    });
    res.json(reports);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /leak-reports:
 * post:
 * summary: Create a new leak report
 * tags: [LeakReports]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * required:
 * - reportDate
 * - severity
 * - status
 * properties:
 * reportDate: { type: string, format: date, description: "YYYY-MM-DD" }
 * locationDescription: { type: string, nullable: true }
 * severity: { type: string, enum: [Minor, Moderate, Major, Critical] }
 * status: { type: string, enum: [Reported, UnderInvestigation, Resolved, Closed, FalseReport, Mitigated] }
 * estimatedWaterLossLitersPerDay: { type: number, format: float, nullable: true }
 * reportedByVillageId: { type: string, format: uuid, nullable: true }
 * assignedToUserId: { type: string, format: uuid, nullable: true }
 * infrastructureAssetId: { type: string, format: uuid, nullable: true }
 * responses:
 * 201:
 * description: Leak report created successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/LeakReport'
 * 400:
 * description: Invalid input
 * 500:
 * description: Server error
 */
exports.createLeakReport = async (req, res) => {
  const {
    reportDate,
    locationDescription,
    severity,
    status,
    estimatedWaterLossLitersPerDay,
    reportedByVillageId,
    assignedToUserId,
    infrastructureAssetId
  } = req.body;
  try {
    const newReport = await prisma.leakReport.create({
      data: {
        reportDate: new Date(reportDate),
        locationDescription,
        severity,
        status,
        estimatedWaterLossLitersPerDay,
        reportedByVillageId,
        assignedToUserId,
        infrastructureAssetId
      }
    });
    res.status(201).json(newReport);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * @swagger
 * /leak-reports/{id}:
 * put:
 * summary: Update an existing leak report
 * tags: [LeakReports]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: path
 * name: id
 * schema:
 * type: string
 * format: uuid
 * required: true
 * description: Leak Report ID
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * properties:
 * reportDate: { type: string, format: date, description: "YYYY-MM-DD" }
 * locationDescription: { type: string, nullable: true }
 * severity: { type: string, enum: [Minor, Moderate, Major, Critical] }
 * status: { type: string, enum: [Reported, UnderInvestigation, Resolved, Closed, FalseReport, Mitigated] }
 * resolutionDate: { type: string, format: date, nullable: true, description: "YYYY-MM-DD" }
 * estimatedWaterLossLitersPerDay: { type: number, format: float, nullable: true }
 * reportedByVillageId: { type: string, format: uuid, nullable: true }
 * assignedToUserId: { type: string, format: uuid, nullable: true }
 * infrastructureAssetId: { type: string, format: uuid, nullable: true }
 * responses:
 * 200:
 * description: Leak report updated successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/LeakReport'
 * 404:
 * description: Leak report not found
 * 500:
 * description: Server error
 */
exports.updateLeakReport = async (req, res) => {
  const { id } = req.params;
  const {
    reportDate,
    locationDescription,
    severity,
    status,
    resolutionDate,
    estimatedWaterLossLitersPerDay,
    reportedByVillageId,
    assignedToUserId,
    infrastructureAssetId
  } = req.body;
  try {
    const updatedReport = await prisma.leakReport.update({
      where: { id },
      data: {
        reportDate: reportDate ? new Date(reportDate) : undefined,
        locationDescription,
        severity,
        status,
        resolutionDate: resolutionDate ? new Date(resolutionDate) : undefined,
        estimatedWaterLossLitersPerDay,
        reportedByVillageId,
        assignedToUserId,
        infrastructureAssetId
      }
    });
    res.json(updatedReport);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// --- 8. routes/authRoutes.js ---
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

/**
 * @swagger
 * /auth/login:
 * post:
 * summary: Authenticate a user or citizen
 * tags: [Authentication]
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/LoginRequest'
 * responses:
 * 200:
 * description: Authentication successful
 * 401:
 * description: Invalid credentials
 * 500:
 * description: Server error
 */
router.post('/login', authController.login);

module.exports = router;


// --- 9. routes/userRoutes.js ---
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

// Mock authentication middleware (replace with real JWT validation in production)
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (token == null) return res.sendStatus(401); // Unauthorized

    // In a real app, verify the token (e.g., jwt.verify)
    // For this example, we'll just assume token presence means authenticated
    next();
};

/**
 * @swagger
 * /users:
 * get:
 * summary: Get all users
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - $ref: '#/components/parameters/roleFilter'
 * responses:
 * 200:
 * $ref: '#/components/responses/UsersList'
 */
router.get('/', authenticateToken, userController.getAllUsers);

/**
 * @swagger
 * /users/{id}:
 * get:
 * summary: Get user by ID
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - $ref: '#/components/parameters/userId'
 * responses:
 * 200:
 * $ref: '#/components/responses/UserResponse'
 */
router.get('/:id', authenticateToken, userController.getUserById);

/**
 * @swagger
 * /users:
 * post:
 * summary: Create a new user
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * required:
 * - username
 * - password
 * - fullName
 * - role
 * - organizationId
 * properties:
 * username: { type: 'string' }
 * password: { type: 'string' }
 * fullName: { type: 'string' }
 * email: { type: 'string', format: 'email', nullable: true }
 * role: { type: 'string', enum: [Administrator, Planner, FieldOfficer, NGOUser] }
 * organizationId: { type: 'string', format: 'uuid' }
 * isActive: { type: 'boolean', default: true }
 * responses:
 * 201:
 * $ref: '#/components/responses/UserResponse'
 */
router.post('/', authenticateToken, userController.createUser);

/**
 * @swagger
 * /users/{id}:
 * put:
 * summary: Update a user
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - $ref: '#/components/parameters/userId'
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * properties:
 * username: { type: 'string' }
 * fullName: { type: 'string' }
 * email: { type: 'string', format: 'email', nullable: true }
 * role: { type: 'string', enum: [Administrator, Planner, FieldOfficer, NGOUser] }
 * organizationId: { type: 'string', format: 'uuid' }
 * isActive: { type: 'boolean' }
 * responses:
 * 200:
 * $ref: '#/components/responses/UserResponse'
 */
router.put('/:id', authenticateToken, userController.updateUser);

/**
 * @swagger
 * /users/{id}:
 * delete:
 * summary: Delete a user
 * tags: [Users]
 * security:
 * - bearerAuth: []
 * parameters:
 * - $ref: '#/components/parameters/userId'
 * responses:
 * 204:
 * description: User deleted successfully
 */
router.delete('/:id', authenticateToken, userController.deleteUser);

module.exports = router;


// --- 10. routes/meterReadingRoutes.js ---
const express = require('express');
const router = express.Router();
const meterReadingController = require('../controllers/meterReadingController');
const { authenticateToken } = require('./userRoutes'); // Re-using mock auth middleware

/**
 * @swagger
 * /meter-readings:
 * get:
 * summary: Get all meter readings
 * tags: [MeterReadings]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: query
 * name: reportedByUserId
 * schema:
 * type: string
 * format: uuid
 * description: Filter readings by the ID of the reporting user (Field Officer or Citizen)
 * - in: query
 * name: meterAssetId
 * schema:
 * type: string
 * format: uuid
 * description: Filter readings by the ID of the meter asset
 * responses:
 * 200:
 * description: A list of meter readings.
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * $ref: '#/components/schemas/MeterReading'
 */
router.get('/', authenticateToken, meterReadingController.getAllMeterReadings);

/**
 * @swagger
 * /meter-readings:
 * post:
 * summary: Create a new meter reading (single)
 * tags: [MeterReadings]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * required:
 * - meterAssetId
 * - readingDate
 * - volumeConsumedLiters
 * - reportedByUserId
 * properties:
 * meterAssetId: { type: string, format: uuid }
 * readingDate: { type: string, format: date }
 * volumeConsumedLiters: { type: number, format: float }
 * reportedByUserId: { type: string, format: uuid }
 * responses:
 * 201:
 * description: Meter reading created successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/MeterReading'
 */
router.post('/', authenticateToken, meterReadingController.createMeterReading);

/**
 * @swagger
 * /meter-readings/bulk:
 * post:
 * summary: Bulk create new meter readings
 * tags: [MeterReadings]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * type: object
 * required:
 * - meterAssetId
 * - readingDate
 * - volumeConsumedLiters
 * - reportedByUserId
 * properties:
 * meterAssetId: { type: string, format: uuid }
 * readingDate: { type: string, format: date }
 * volumeConsumedLiters: { type: number, format: float }
 * reportedByUserId: { type: string, format: uuid }
 * responses:
 * 201:
 * description: Meter readings created successfully
 * content:
 * application/json:
 * schema:
 * type: object
 * properties:
 * count: { type: number, description: "Number of readings created" }
 * message: { type: string }
 */
router.post('/bulk', authenticateToken, meterReadingController.bulkCreateMeterReadings);

module.exports = router;


// --- 11. routes/leakReportRoutes.js ---
const express = require('express');
const router = express.Router();
const leakReportController = require('../controllers/leakReportController');
const { authenticateToken } = require('./userRoutes'); // Re-using mock auth middleware

/**
 * @swagger
 * /leak-reports:
 * get:
 * summary: Get all leak reports
 * tags: [LeakReports]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: query
 * name: status
 * schema:
 * type: string
 * enum: [Reported, UnderInvestigation, Resolved, Closed, FalseReport, Mitigated]
 * description: Filter reports by status
 * - in: query
 * name: assignedToUserId
 * schema:
 * type: string
 * format: uuid
 * description: Filter reports by assigned user ID (for Field Officers)
 * responses:
 * 200:
 * description: A list of leak reports.
 * content:
 * application/json:
 * schema:
 * type: array
 * items:
 * $ref: '#/components/schemas/LeakReport'
 */
router.get('/', authenticateToken, leakReportController.getAllLeakReports);

/**
 * @swagger
 * /leak-reports:
 * post:
 * summary: Create a new leak report
 * tags: [LeakReports]
 * security:
 * - bearerAuth: []
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * required:
 * - reportDate
 * - severity
 * - status
 * properties:
 * reportDate: { type: string, format: date }
 * locationDescription: { type: string, nullable: true }
 * severity: { type: string, enum: [Minor, Moderate, Major, Critical] }
 * status: { type: string, enum: [Reported, UnderInvestigation, Resolved, Closed, FalseReport, Mitigated] }
 * estimatedWaterLossLitersPerDay: { type: number, format: float, nullable: true }
 * reportedByVillageId: { type: string, format: uuid, nullable: true }
 * assignedToUserId: { type: string, format: uuid, nullable: true }
 * infrastructureAssetId: { type: string, format: uuid, nullable: true }
 * responses:
 * 201:
 * description: Leak report created successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/LeakReport'
 */
router.post('/', authenticateToken, leakReportController.createLeakReport);

/**
 * @swagger
 * /leak-reports/{id}:
 * put:
 * summary: Update an existing leak report
 * tags: [LeakReports]
 * security:
 * - bearerAuth: []
 * parameters:
 * - in: path
 * name: id
 * schema:
 * type: string
 * format: uuid
 * required: true
 * description: Leak Report ID
 * requestBody:
 * required: true
 * content:
 * application/json:
 * schema:
 * type: object
 * properties:
 * reportDate: { type: string, format: date }
 * locationDescription: { type: string, nullable: true }
 * severity: { type: string, enum: [Minor, Moderate, Major, Critical] }
 * status: { type: string, enum: [Reported, UnderInvestigation, Resolved, Closed, FalseReport, Mitigated] }
 * resolutionDate: { type: string, format: date, nullable: true }
 * estimatedWaterLossLitersPerDay: { type: number, format: float, nullable: true }
 * reportedByVillageId: { type: string, format: uuid, nullable: true }
 * assignedToUserId: { type: string, format: uuid, nullable: true }
 * infrastructureAssetId: { type: string, format: uuid, nullable: true }
 * responses:
 * 200:
 * description: Leak report updated successfully
 * content:
 * application/json:
 * schema:
 * $ref: '#/components/schemas/LeakReport'
 */
router.put('/:id', authenticateToken, leakReportController.updateLeakReport);

module.exports = router;


// --- 12. server.js ---
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./config/swaggerConfig');
const prisma = require('./utils/prisma'); // Import prisma client for database connection check

// --- Import all routes ---
const authRoutes = require('./routes/authRoutes');
const userRoutes = require('./routes/userRoutes');
// ... other routes (organization, region, district, village, waterSourceType, waterSource,
// infraAssetType, infraAsset, meterReading, leakReport, waterQualityTest,
// citizenAccount, property, bill, announcement)

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors()); // Enable CORS for all origins (adjust in production)
app.use(bodyParser.json()); // Parse JSON request bodies

// API Routes
app.use('/api/v1/auth', authRoutes);
app.use('/api/v1/users', userRoutes);
app.use('/api/v1/meter-readings', require('./routes/meterReadingRoutes'));
app.use('/api/v1/leak-reports', require('./routes/leakReportRoutes'));
// Add all other routes here...
// app.use('/api/v1/organizations', require('./routes/organizationRoutes'));
// app.use('/api/v1/regions', require('./routes/regionRoutes'));
// app.use('/api/v1/districts', require('./routes/districtRoutes'));
// app.use('/api/v1/villages', require('./routes/villageRoutes'));
// app.use('/api/v1/water-source-types', require('./routes/waterSourceTypeRoutes'));
// app.use('/api/v1/water-sources', require('./routes/waterSourceRoutes'));
// app.use('/api/v1/infrastructure-asset-types', require('./routes/infraAssetTypeRoutes'));
// app.use('/api/v1/infrastructure-assets', require('./routes/infraAssetRoutes'));
// app.use('/api/v1/water-quality-tests', require('./routes/waterQualityTestRoutes'));
// app.use('/api/v1/citizen-accounts', require('./routes/citizenAccountRoutes'));
// app.use('/api/v1/properties', require('./routes/propertyRoutes'));
// app.use('/api/v1/bills', require('./routes/billRoutes'));
// app.use('/api/v1/announcements', require('./routes/announcementRoutes'));


// Swagger API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Basic health check endpoint
app.get('/', (req, res) => {
  res.send('WaterNet API is running! Access API docs at /api-docs');
});

// Start the server
async function startServer() {
  try {
    // Connect to the database
    await prisma.$connect();
    console.log('Database connected successfully!');

    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
      console.log(`Swagger docs available at http://localhost:${PORT}/api-docs`);
    });
  } catch (error) {
    console.error('Failed to connect to database or start server:', error);
    process.exit(1); // Exit with failure code
  }
}

startServer();

// Graceful shutdown
process.on('SIGINT', async () => {
  await prisma.$disconnect();
  console.log('Database disconnected. Server shutting down.');
  process.exit(0);
});
